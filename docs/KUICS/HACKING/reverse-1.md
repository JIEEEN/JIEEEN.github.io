---
layout: default
title: '리버스 엔지니어링 1'
nav_order: 2
parent: '기초해킹'
grand_parent: KUICS
---

# 리버스 엔지니어링 1

## 리버스 엔지니어링이란
- 해킹의 기본
  - 해킹은 네가지 단계로 이루어짐
    - 컴퓨터 시스템 분석 -> 내부 원리 파악 -> 의도하지 않은 동작을 이끌어냄 -> 목표 달성
    - 이 중 __앞 두단계가 리버싱의 원리와 동일__
- 사전적 정의: 완성된 제품을 해체해 구조를 분석하는것
  - 전기회로, 무기체계, 소프트웨어 등.. 분석 대상이 다양하다
  - 소프트웨어 리버싱은 내부 구조와 동작 원리를 파악하는 것
- 리버싱은 악용할 수 있지만, 저작권법 101조의 4에 리버싱을 할 수 있는 조건이 적혀있다
    <img width="774" alt="image" src="https://github.com/JIEEEN/JIEEEN.github.io/assets/63636210/d88d8736-4972-4ce3-acb2-9b184af6c6e8">
  - 허락받지 않고 리버싱을 이용할 경우 "법적인 제재"를 받을 수 있다.

## 바이너리
- 바이너리 = 프로그램
  - 왜 프로그램이 바이너리인가?
  - 프로그램 -> 기계어 덩어리 -> 이진수로 이루어짐 -> 바이너리
- 컴퓨터에게 명령하기 위한 코드와 데이터의 묶음
  - 컴퓨터구조시간에 배운것. elf파일을 까보면 text, data, ... 로 이루어져있었던 것이 기억난다.
- 소스코드를 바이너리로 만드는과정
  - 전처리
    - test.c라는 c파일을 만들었지만, 이 파일은 그저 txt 파일에 불과함
    - #define MAX 10000... 과같은 코드들을 변환함
  - 컴파일
    - test.c라는 파일을 test.s (혹은 test.asm) 으로 변환
      - 어셈블리어로 이루어진 파일
      - 어셈블리어는 기계어를 보다 더 추상화시킨, 사람에게 좀 더 친숙한 기계어라 생각하면 됨
    - 기계어와 어셈블리어는 1대1 대응됨
    - 아직까지 s, asm파일도 text 파일이라고 봐야됨
  - 어셈블 + alpha
    - test.asm -> test.exe
    - 어셈블리어와 기계어는 1대1로 대응하므로, 어셈블리어를 기계어로 변환해주는 작업을 수행
  
## 리버싱의 과정
- 위에서 나열한 것들을 반대로 거슬러 올라가는 과정
- 기계어 -> 어셈블리 -> 소스코드 ...
### 디스어셈블
  - 바이너리 -> 어셈블리어
  - test.exe를 뜯어보면 기계어들이 있음
    - Main함수, Func1, Func2가 있다고 가정해보자
    - __선형디스어셈블__
      - Main -> Func1 -> Func2 순서대로 소스코드가 형성돼있다고 할 때, 위에서 순차적으로 Main -> Func1 -> Func2 순서대로 디스어셈블 하는것
      - 장점 : 빠르다
      - 단점 : Main함수는 기계어로 적혀있어야되는게 맞는데, 특정 컴파일러는 Main함수에 데이터를 넣는 경우도 있음. 
      데이터를 기계어로 생각을 하는순간 어셈블리어는 의미가 없어짐.
      - 대표적 도구 : objdump
    - __재귀적디스어셈블__
      - Main을 찾고, 찾게되면 쭈욱 디스어셈블을 하다가 함수 호출을 발견하면 그 함수로 넘어가서 디스어셈블을 반복하는 과정 ..
      - 호출이 끝나면 caller에게 돌아가서 다시 디스어셈블
      - 장점 : 확실히 함수만 디스어셈블할 가능성이 높아짐
      - 단점 : Func2가 분명 있지만, 제대로 구현이 된 코드가 아니라 Func2에 접근하지 못할수가 있음. __코드 커버리지의 문제 발생 가능__
      - 대표적 도구 : IDA
  - 기계어와 어셈블리어는 1대1 대응이므로, 상대적으로 디스어셈블 과정은 매우 쉽다.
  - 하지만 어셈블리어도 인간에게 친숙한 text는 아니므로, 가장 happy한 결말은 해당 기계어로 이루어진 __source code__ 를 찾는 것이다.
### 디컴파일
  - 바이너리 -> 소스코드
  - 문제는 C 소스코드와 어셈블리어는 1대1 대응이 되지 않음
    - 말도 안되게 높은 난이도..
  - 디스어셈블을 하고나면 CFG (Control Flow Graph)를 생성할 수 있음
  - 구조 분석
    - 어떤 조건에서는 어떻게 처리하고, 여긴 반복문이고... 등의 것들을 파악 가능
  - Code emition
    - 실제 어셈블리어를 소스코드로 번역해주는 과정

## 정적분석과 동적분석
- 정적분석
  - 프로그램 실행하지 않고 분석하는 방법
  - 장점 : 프로그램의 전체 구조를 파악하기 용이, 분석환경의 제약사항을 극복
  - 단점 : 난독화 (프로그램을 읽기 힘들게 만든 것)가 돼있으면 정적분석하기 힘듦
- 동적분석
  - 프로그램을 실행하여 분석하는 방법   
  - 장점 : 개별동작을 파악하기 용이
  - 단점 : 실행못하면 무용지물, 악성코드 존재 가능